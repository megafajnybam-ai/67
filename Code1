// ==UserScript==
// @name         GeoFS Extra Vehicles
// @version      1.4
// @description  Adds extra vehicles to GeoFS
// @author       AF267
// @updateURL    https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/main.js
// @downloadURL  https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/main.js
// @match        https://geo-fs.com/geofs.php*
// @match        https://*.geo-fs.com/geofs.php*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=geo-fs.com
// @grant        none
// ==/UserScript==

(function () {
    'use strict';
    console.log("Extras script running...");

    // ALWAYS CHANGE BACK TO THIS:
    // https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/vehicles.json
    const DATA_URL = "https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/vehicles.json";

    const aircraftButton = document.querySelector('button[data-toggle-panel=".geofs-aircraft-list"]');
    if (!aircraftButton) {
        console.warn("Aircraft button not found.");
        return;
    }

    const extrasButton = aircraftButton.cloneNode(true);
    extrasButton.textContent = "Extras";
    extrasButton.removeAttribute("data-toggle-panel");
    extrasButton.setAttribute("data-toggle-panel", ".geofs-extras-list");
    extrasButton.id = "extras-button";
    aircraftButton.parentNode.insertBefore(extrasButton, aircraftButton);

    const extrasPanel = document.createElement("ul");
    extrasPanel.className = "geofs-list geofs-extras-list geofs-toggle-panel";

    // create div, temporary header only
    extrasPanel.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px; padding-left: 20px;">
            <img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/JXT%20Logo.png" style="width: 100px; height: auto;" />
            <h4 style="margin: 0;">GeoFS Extra Vehicles</h4>
        </div>
    `;

    const aircraftPanel = document.querySelector(".geofs-aircraft-list");
    if (aircraftPanel && aircraftPanel.parentNode) {
        aircraftPanel.parentNode.insertBefore(extrasPanel, aircraftPanel.nextSibling);
    }

    function createCategorySection(title, items) {
        const category = document.createElement("li");
        category.className = "geofs-list-collapsible-item";
        category.textContent = title;

        const sublist = document.createElement("ul");
        sublist.className = "geofs-collapsible";

        items.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })); // alphabetical sorting

        items.forEach(item => {
            const li = document.createElement("li");
            li.setAttribute("data-url", item.url);
            li.setAttribute("data-mpid", item.id);

            const itemContent = document.createElement("span");
            const nameText = document.createTextNode(item.name);
            itemContent.appendChild(nameText);
            if (item.mp) {
                const mpIcon = document.createElement("img");
                mpIcon.style.width = "20px";
                mpIcon.style.height = "20px";
                mpIcon.style.marginLeft = "8px";

                if (item.mp === "green") {
                    mpIcon.src = "https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/green.png";
                } else if (item.mp === "yellow") {
                    mpIcon.src = "https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/yellow.png";
                } else if (item.mp === "red") {
                    mpIcon.src = "https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/red.png";
                }
                // this part is new, comment out if needed
                else if (item.mp === "addon") {
                    mpIcon.src = "https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/addon.png";
                    geofs.aircraftList[item.id] = {
                        id: item.id,
                        community: 1,
                        multiplayerFiles: "",
                        name: item.name,
                        path: item.url
                    }
                }
                // end new part

                itemContent.appendChild(mpIcon);
            }
            if (item.ls) {
                const lsIcon = document.createElement("img");
                lsIcon.style.width = "20px";
                lsIcon.style.height = "20px";
                lsIcon.style.marginLeft = "8px";

                if (item.ls === 1) {
                    lsIcon.src = "https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/ls-logo.png";
                }

                itemContent.appendChild(lsIcon);
            }

            li.appendChild(itemContent);

            sublist.appendChild(li);
        });

        category.appendChild(sublist);
        return category;
    }

    // add about section to the end
    function appendAboutSection() {
        const aboutSection = document.createElement("li");
        aboutSection.className = "geofs-list-collapsible-item";
        aboutSection.textContent = "About";

        const aboutContent = document.createElement("ul");
        aboutContent.className = "geofs-collapsible";
        aboutContent.innerHTML = `
            <a href="https://github.com/af267/GeoFS-Extra-Vehicles" target="_blank" rel="nofollow"><h4>Current Version: 1.4</h4></a>
            <p>GeoFS Extra Vehicles is a privately maintained addon not associated with GeoFS.</p>
            <p>GeoFS Extra Vehicles is an addon developed by AF267 that adds external vehicles from JAaMDG's JXT Group as well as unreleased projects into the simulator.</p>
            <h5>Multiplayer Models</h5>
            <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/green.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model supported</span>
            <br/>
            <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/addon.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model only supported via addon</span>
            <br/>
            <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/yellow.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model shows, but of another similar vehicle</span>
            <br/>
            <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/red.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model not supported</span>
            <br/>
            <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/ls-logo.png" style="width: 24px; height: auto; margin: 8px">Compatible with <a src="https://github.com/kolos26/GEOFS-LiverySelector" target="_blank">LiverySelector</a> (must be enabled, does not guarantee multiplayer liveries supported)</span>
            <p>If you have any questions or if you have an aircraft (must have a working aircraft.json) you would like to add, visit the JAaMDG Discord</p>
            <a href="https://discord.gg/fcFQH6Qhb7" target="_blank" rel="nofollow"><img src="https://www.geo-fs.com/images/discord.png" style="margin: 10px 10px 10px 0px;"/></a>
            <p>Copyright Â© AF267 - 2025</p>
        `;
        aboutSection.appendChild(aboutContent);
        extrasPanel.appendChild(aboutSection);
    }

    function loadAircraftFromUrl(baseUrl, mpID, name) {
        $.ajax(baseUrl + "aircraft.json", {
            dataType: "text",
            success: function (jsonText) {
                var customRecord = {
                    id: "custom_" + Date.now(),
                    name: name,
                    fullPath: baseUrl,
                    isPremium: false,
                    isCommunity: false,
                    definition: btoa(jsonText),
                    multiplayerFiles: [
                        baseUrl + "multiplayer.glb",
                        baseUrl + "multiplayer-low.glb"
                    ]
                };

                var parsedDefinition = geofs.aircraft.instance.parseRecord(JSON.stringify(customRecord));

                if (parsedDefinition) {
                    geofs.aircraft.instance.unloadAircraft();
                    customRecord.id = mpID;
                    geofs.aircraft.instance.id = mpID;
                    geofs.aircraft.instance.fullPath = customRecord.fullPath;
                    geofs.aircraft.instance.aircraftRecord = customRecord;
                    geofs.aircraft.instance.init(parsedDefinition, geofs.aircraft.instance.getCurrentCoordinates());

                } else {
                    ui.notification.show("Failed to parse aircraft.json");
                }
            },
            error: function () {
                ui.notification.show("Could not load aircraft.json");
            }
        });
    }

    extrasPanel.addEventListener("click", function (e) {
        const li = e.target.closest("li[data-url]");
        if (li) {
            const url = li.getAttribute("data-url");
            const mpID = li.getAttribute("data-mpid");
            const name = li.textContent || li.innerText;
            loadAircraftFromUrl(url, mpID, name);
        }
    });

    fetch(DATA_URL)
        .then(response => response.json())
        .then(data => {
            for (const [category, items] of Object.entries(data)) {
                const section = createCategorySection(category, items);
                extrasPanel.appendChild(section);
            }
            appendAboutSection();
        })
        .catch(error => {
            console.error("Error loading vehicle data:", error);

            // emergency purposes backup
            extrasPanel.innerHTML += `
                <div style="display: flex; align-items: center; gap: 10px; padding-left: 20px;">
                    <img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/JXT%20Logo.png" style="width: 100px; height: auto;" />
                    <h4 style="margin: 0;">GeoFS Extra Vehicles</h4>
                    <p>Error: Too many requests to GitHub. Could not load latest JSON data. Incomplete list of vehicles.
                </div>
                <li class="geofs-list-collapsible-item">
                    Aircraft
                    <ul class="geofs-collapsible">
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/md11_380019_5369/" data-mpid="1023">McDonnell Douglas MD-11 (ADSB)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/c25a_380019_5367/" data-mpid="1021">Cessna Citation CJ2 (ADSB)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/heli_380019_5371/" data-mpid="1025">Eurocopter AS365 Dauphin (ADSB)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/e190_380019_5372/" data-mpid="1018">Embraer E190 (ADSB)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/crj900_380019_5389/" data-mpid="1016">Bombardier CRJ900 (ADSB)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/A160_267286_3007/" data-mpid="50">Paramotor (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/P180Y_267286_3557/" data-mpid="2000">Starship SN5 (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/NK-V_267286_2525/" data-mpid="1014">Ilyushin Il-76TD (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Piper%20XCub_380019_3226/" data-mpid="1">Piper PA-18 Super Cub (GeoFS)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Cessna%20Skymaster%20(Nightheart/Kitten-cat)_380019_4792/" data-mpID="2">Cessna 337 Super Skymaster (by Nightheart)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Hang%20Glider%20Belgium_380019_3111/" data-mpid="50">Hang Glider Belgium (by Johani)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Sikorsky UH-60 Black Hawk_380019_3068/" data-mpid="2806">Sikorsky UH-60 Black Hawk (by Spice_9)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/c650_380019_5390/" data-mpid="2706">Bombardier Challenger 650 (by Ryan Xu)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/72e_380019_5519/" data-mpid="1005">Boeing 777-200ER (by MirageModels)</li>
                    </ul>
                </li>
                <li class="geofs-list-collapsible-item">
                    Ground Vehicles
                    <ul class="geofs-collapsible">
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/truck_380019_5368/" data-mpid="1027">Food Service Truck (ADSB)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/NeoAD XTerra_267286_4894/" data-mpid="1027">XTerra SUV (2024 APRIL FOOLS) (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Steelbird Sagittarius Pulsar_267286_5155/" data-mpid="102">Sagittarius Hypercar (2025 APRIL FOOLS) (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/miata2_380019_5509/" data-mpid="102">Mazda MX-5 Miata (by MirageModels)</li>
                    </ul>
                </li>
                <li class="geofs-list-collapsible-item">
                    Miscellaneous
                    <ul class="geofs-collapsible">
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/CMV Probability_267286_5009/" data-mpid="2000">CMV Probability Megayacht (2025 APRIL FOOLS) (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/X2000BWB_267286_2329/" data-mpid="2000">Northtech RADIO (2025 APRIL FOOLS) (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Northtech UTOPIA_267286_4136/" data-mpid="2000">Northtech UTOPIA (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/ARCHANGEL_267286_3974/" data-mpid="2000">Northtech ARCHANGEL (2023 APRIL FOOLS) (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Proximus Hovercraft_267286_4644/" data-mpid="2000">Proximus Hovercraft (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/WK2 testbed_267286_2783/" data-mpid="5193">Boeing 747x (2025 APRIL FOOLS) (by AF267)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/type055_380019_5388/" data-mpid="2000">Type 055 Destroyer (by MirageModels)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/Jetpack_380019_5385/" data-mpid="103">Jetpack Wingsuit (by GeoFS & Nightheart)</li>
                    </ul>
                </li>
                <li class="geofs-list-collapsible-item">
                    Archived
                    <ul class="geofs-collapsible">
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/alphajet_380019_5403/" data-mpid="3">Dassault-Dornier Alpha Jet (by GeoFS)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/dc3_380019_5401/" data-mpid="16">Douglas DC-3 (by GeoFS)</li>
                        <li data-url="https://www.geo-fs.com/backend/aircraft/repository/a380_380019_5402/" data-mpid="1012">Airbus A380 (by GeoFS)</li>
                    </ul>
                </li>
                <li class="geofs-list-collapsible-item">
                    About
                    <ul class="geofs-collapsible">
                        <a href="https://github.com/af267/GeoFS-Extra-Vehicles" target="_blank" rel="nofollow"><h4>Current Version: 1.4</h4></a>
                        <p>GeoFS Extra Vehicles is a privately maintained addon not associated with GeoFS.</p>
                        <p>GeoFS Extra Vehicles is an addon developed by AF267 that adds external vehicles from JAaMDG's JXT Group as well as unreleased projects into the simulator.</p>
                        <h5>Multiplayer Models</h5>
                        <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/green.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model supported</span>
                        <br/>
                        <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/addon.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model only supported via addon</span>
                        <br/>
                        <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/yellow.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model shows, but of another similar vehicle</span>
                        <br/>
                        <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/red.png" style="width: 24px; height: auto; margin: 8px">Multiplayer model not supported</span>
                        <br/>
                        <span><img src="https://raw.githubusercontent.com/af267/GeoFS-Extra-Vehicles/refs/heads/main/ls-logo.png" style="width: 24px; height: auto; margin: 8px">Compatible with <a src="https://github.com/kolos26/GEOFS-LiverySelector" target="_blank">LiverySelector</a> (must be enabled, does not guarantee multiplayer liveries supported)</span>
                        <p>If you have any questions or if you have an aircraft (must have a working aircraft.json) you would like to add, visit the JAaMDG Discord</p>
                        <a href="https://discord.gg/fcFQH6Qhb7" target="_blank" rel="nofollow"><img src="https://www.geo-fs.com/images/discord.png" style="margin: 10px 10px 10px 0px;"/></a>
                        <p>Copyright Â© AF267 - 2025</p>
                    </ul>
                </li>
            `;
        });

})();
const githubRepo = 'https://raw.githubusercontent.com/kolos26/GEOFS-LiverySelector/main';
let jsDelivr = 'https://cdn.jsdelivr.net/gh/kolos26/GEOFS-LiverySelector@main';
const noCommit = jsDelivr;
const version = '3.4.1';

const liveryobj = {};
const mpLiveryIds = {};
const mLiveries = {};
const origHTMLs = {};
const uploadHistory = JSON.parse(localStorage.lsUploadHistory || '{}');
const LIVERY_ID_OFFSET = 10e3;
const ML_ID_OFFSET = 1e3;
let links = [];
let airlineobjs = [];
let whitelist;
let mpAirlineobjs = {};
const LOG_STYLE = "white-space:nowrap;display:inline;color:";
const log = (e, t = "log") => console[t]("%c[%cLivery%cSelector%c] %c", LOG_STYLE + "inherit;", LOG_STYLE + "#bcc3cb;", LOG_STYLE + "#3f5f8a;", LOG_STYLE + "inherit;", LOG_STYLE + "inherit;", e);

(async function init() {
    // find latest commit to ensure the latest files are fetched from jsDelivr
    try {
        const res = await fetch(`https://api.github.com/repos/kolos26/GEOFS-LiverySelector/commits/main`);
        if (!res.ok) jsDelivr = githubRepo;
        const commit = (await res.json()).sha;
        if (!/^[a-f0-9]{40}$/.test(commit)) jsDelivr = githubRepo;
        jsDelivr = jsDelivr.replace("@main", `@${commit}`);
    } catch (err) {jsDelivr = githubRepo};
    
    // styles
    fetch(`${jsDelivr}/styles.css?` + Date.now()).then(async data => {
        const styleTag = createTag('style', { type: 'text/css' });
        styleTag.textContent = await data.text();
        document.head.appendChild(styleTag);
    });

    //Load liveries (@todo: consider optimising livery.json or converting it to a different datatype)
    fetch(`${jsDelivr}/livery.json?` + Date.now()).then(handleLiveryJson);
    
    // Panel for list
    const listDiv = appendNewChild(document.querySelector('.geofs-ui-left'), 'div', {
        id: 'listDiv',
        class: 'geofs-list geofs-toggle-panel livery-list',
        'data-noblur': 'true',
        'data-onshow': '{geofs.initializePreferencesPanel()}', // are these properties needed?
        'data-onhide': '{geofs.savePreferencesPanel()}'
    });
	listDiv.innerHTML = generateListHTML();
	
    // one big event listener for the main livery list instead of multiple event listeners
	const livList = document.querySelector("#liverylist");
    livList.addEventListener('click', function ({ target }) {
		if (target.nodeName === "I") return void window.LiverySelector.star(target); // if the element clicked is a star, run the star function
        const idx = parseInt(target.closest('li').getAttribute('data-idx')); // convert to int because attributes are stored as strings
        if (idx === void 0) return; // avoid livery selection when other stuff is pressed
        const airplane = LiverySelector.liveryobj.aircrafts[geofs.aircraft.instance.id]
        , livery = airplane.liveries[idx];
        livery.disabled || (loadLivery(livery.texture, airplane.index, airplane.parts, livery.materials),
        livery.mp != 'disabled' && setInstanceId(idx + (livery.credits?.toLowerCase() == 'geofs' ? 0 : LIVERY_ID_OFFSET)));
    }); // uses || (logical OR) to run the right side code only if livery.disabled is falsy
    livList.addEventListener('error', function(e) {
		const defaultThumb = `${noCommit}/thumbs/${geofs.aircraft.instance.id}.png`;
		if (e.target.tagName !== 'IMG' || e.target.src === defaultThumb) return;
		e.target.onerror = null;
		e.target.src = defaultThumb;
    }, true);
	
    document.querySelector("#listDiv > ul#favorites").addEventListener("click", function ({ target }) {
        if (target.nodeName != "LI") return;
		const $match = $(`#liverylist > [id='${$(target).attr("id").replace("_favorite", "_button")}']`) // find the matching livery list item
		if ($match.length === 0) return void ui.notification.show(`ID: ${$(target).attr("id")} is missing a liveryList counterpart.`)
		$match.click();
	});

	const potatoCheckbox = document.querySelector("#livery-potato-mode");
	potatoCheckbox.addEventListener("change", function () {
		geofs.setPreferenceFromInput(this);
		document.querySelector(".potato-mode-search").classList.toggle("geofs-visible", this.checked);
		geofs.savePreferences();
		window.LiverySelector[this.checked ? "potatoSearch" : "search"](document.querySelector("#searchlivery").value);
	});
	window.executeOnEventDone("geofsInitialized", () => {
		potatoCheckbox.checked = geofs.preferences.liveryPotato;
		document.querySelector(".potato-mode-search").classList.toggle("geofs-visible", potatoCheckbox.checked);
	});
	document.querySelector(".potato-mode-search").addEventListener("click", function () {
		if (!geofs.preferences.liveryPotato) return;
		window.LiverySelector.potatoSearch(document.querySelector("#searchlivery").value);
	})
    // Button for panel
    const geofsUiButton = document.querySelector('.geofs-ui-bottom');
    const insertPos = geofs.version >= 3.6 ? 4 : 3;
    geofsUiButton.insertBefore(generatePanelButtonHTML(), geofsUiButton.children[insertPos]);

    //remove original buttons
    const origButtons = document.getElementsByClassName('geofs-liveries geofs-list-collapsible-item');
    Object.values(origButtons).forEach(btn => btn.parentElement.removeChild(btn));

    //Init airline databases
    if (localStorage.getItem('links') === null) {
        localStorage.links = '';
    } else {
        links = localStorage.links.split(",");
        links.forEach(async function (e) {
            await fetch(e).then(res => res.json()).then(data => airlineobjs.push(data));
            airlineobjs[airlineobjs.length - 1].url = e.trim();
        });
    }
    fetch(`${jsDelivr}/whitelist.json?` + Date.now()).then(res => res.json()).then(data => whitelist = data);

    // Start multiplayer
    setInterval(updateMultiplayer, 5000);

    window.addEventListener("keyup", function (e) {
        if (e.target.classList.contains("geofs-stopKeyupPropagation")) {
            e.stopImmediatePropagation();
        }
        if (e.key === "l") {
            LiverySelector.togglePanel();
        }
    });
})();

/**
 * @param {Response} data
 */
async function handleLiveryJson(data) {
    const json = await data.json();
    Object.keys(json).forEach(key => liveryobj[key] = json[key]);
    
    if (liveryobj.commit) jsDelivr = jsDelivr.replace("@main", "@" + liveryobj.commit)
    
    if (liveryobj.version != version) {
        document.querySelector('.livery-list h3').appendChild(
            createTag('a', {
                href: 'https://github.com/kolos26/GEOFS-LiverySelector/releases/latest',
                target: '_blank',
                style: 'display:block;width:100%;text-decoration:none;text-align:center;'
            }, 'Update available: ' + liveryobj.version)
        );
    }
    // mark aircraft with livery icons
    Object.keys(liveryobj.aircrafts).forEach(aircraftId => {
        if (!liveryobj.aircrafts[aircraftId].logo || liveryobj.aircrafts[aircraftId].liveries.length < 2) {
            return; // only show icon if there's more than one livery, also return if only the id is used by extra vehicles
        }
        const element = document.querySelector(`[data-aircraft='${aircraftId}']`);
        // save original HTML for later use (reload, aircraft change, etc..)
        if (element) {
            if (!origHTMLs[aircraftId]) {
                origHTMLs[aircraftId] = element.innerHTML;
            }

        // use orig HTML to concatenate so theres only ever one icon
        element.innerHTML = origHTMLs[aircraftId] +
            createTag('img', {
                src: `${noCommit}/liveryselector-logo-small.svg`,
                style: 'height:30px;width:auto;margin-left:20px;',
                title: 'Liveries available'
            }).outerHTML;

        if (liveryobj.aircrafts[aircraftId].mp != "disabled")
            element.innerHTML += createTag('small', {
                title: 'Liveries are multiplayer compatible\n(visible to other players)'
            }, 'ðŸŽ®').outerHTML;
        }
        });

        Object.keys(liveryobj.aircrafts).forEach(aircraftId => {
            liveryobj.aircrafts[aircraftId].liveries.forEach((e, t) => e.idx ||= t);
            liveryobj.aircrafts[aircraftId].liveries.sort((e, t) => e.name.localeCompare(t.name, undefined, { sensitivity: 'base' }));
        })
}

/**
 * Triggers GeoFS API to load texture
 *
 * @param {string[]} texture
 * @param {number[]} index
 * @param {number[]} parts
 * @param {Object[]} mats
 */
function loadLivery(texture, index, parts, mats) {
    //change livery
    for (let i = 0; i < texture.length; i++) {
        const model3d = geofs.aircraft.instance.definition.parts[parts[i]]['3dmodel'];
        // check for material definition (for untextured parts)
        if (typeof texture[i] === 'object') {
            if (texture[i].material !== undefined) {
                const mat = mats[texture[i].material];
                model3d._model.getMaterial(mat.name)
                    .setValue(Object.keys(mat)[1], new Cesium.Cartesian4(...mat[Object.keys(mat)[1]], 1.0));
            }
            continue;
        }
		try {
	        if (geofs.version == 2.9) {
	            geofs.api.Model.prototype.changeTexture(texture[i], index[i], model3d);
	        } else if (geofs.version >= 3.0 && geofs.version <= 3.7) {
	            geofs.api.changeModelTexture(model3d._model, texture[i], index[i]);
	        } else {
	            geofs.api.changeModelTexture(model3d._model, texture[i], { index: index[i] });
	        }
		} catch (error) {
			geofs.api.notify("Hmmm... we can't find this livery, check the console for more info.");
			(error, "error");
		}
    }
}

/**
 * Load liveries from text input fields
 */
function inputLivery() {
    const airplane = getCurrentAircraft();
    const textures = airplane.liveries[0].texture;
    const inputFields = document.getElementsByName('textureInput');
    if (textures.filter(x => x === textures[0]).length === textures.length) { // the same texture is used for all indexes and parts
        const texture = inputFields[0].value;
        loadLivery(Array(textures.length).fill(texture), airplane.index, airplane.parts);
    } else {
        const texture = [];
        inputFields.forEach(e => texture.push(e.value));
        loadLivery(texture, airplane.index, airplane.parts);
    }
}

/**
 * Submit livery for review
 */
function submitLivery() {
    const airplane = getCurrentAircraft();
    const textures = airplane.liveries[0].texture;
    const inputFields = document.getElementsByName('textureInput');
    const formFields = {};
    document.querySelectorAll('.livery-submit input').forEach(f => formFields[f.id.replace('livery-submit-', '')] = f);
    if (!localStorage.liveryDiscordId || localStorage.liveryDiscordId.length < 6) {
        return alert('Invalid Discord User id!');
    }
    if (formFields.liveryname.value.trim().length < 3) {
        return alert('Invalid Livery Name!');
    }
    if (!formFields['confirm-perms'].checked || !formFields['confirm-legal'].checked) {
        return alert('Confirm all checkboxes!');
    }
    const json = {
        name: formFields.liveryname.value.trim(),
        credits: formFields.credits.value.trim(),
        texture: [],
        materials: {}
    };
    if (!json.name || json.name.trim() == '') {
        return;
    }
    const hists = [];
    const embeds = [];
    inputFields.forEach((f, i) => {
      (f.type)
      if (f.type === "text"){
        f.value = f.value.trim();
        if (f.value.match(/^https:\/\/.+/i)) {
            const hist = Object.values(uploadHistory).find(o => o.url == f.value);
            if (!hist) {
                return alert('Only self-uploaded imgbb links work for submitting!');
            }
            if (hist.expiration > 0) {
                return alert('Can\' submit expiring links! DISABLE "Expire links after one hour" option and re-upload texture:\n' + airplane.labels[i]);
            }
            const embed = {
                title: airplane.labels[i] + ' (' + (Math.ceil(hist.size / 1024 / 10.24) / 100) + 'MB, ' + hist.width + 'x' + hist.height + ')',
                description: f.value,
                image: { url: f.value },
                fields: [
                    { name: 'Timestamp', value: new Date(hist.time * 1e3), inline: true },
                    { name: 'File ID', value: hist.id, inline: true },
                ]
            };
            if (hist.submitted) {
                if (!confirm('The following texture was already submitted:\n' + f.value + '\nContinue anyway?')) {
                    return;
                }
                embed.fields.push({ name: 'First submitted', value: new Date(hist.submitted * 1e3) });
            }
            embeds.push(embed);
            hists.push(hist);
            json.texture.push(f.value);
        } else {
            json.texture.push(textures[i]);
        }
        } else if (f.type === "color"){
            json.materials[f.id] = [parseInt(f.value.substring(1, 3), 16) / 255, parseInt(f.value.substring(3, 5), 16) / 255, parseInt(f.value.substring(5, 7), 16) / 255]
	} 
   });
    if (!embeds.length)
        return alert('Nothing to submit, upload images first!');

    let content = [
        `Livery upload by <@${localStorage.liveryDiscordId}>`,
        `__Plane:__ \`${geofs.aircraft.instance.id}\` ${geofs.aircraft.instance.aircraftRecord.name}`,
        `__Livery Name:__ \`${json.name}\``,
        '```json\n' + JSON.stringify(json, null, 2) + '```'
    ];

    fetch(atob(liveryobj.dapi), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: content.join('\n'), embeds })
    }).then(res => {
        hists.forEach(hist => {
            hist.submitted = hist.submitted || Math.round(new Date() / 1000);
        });
        localStorage.lsUploadHistory = JSON.stringify(uploadHistory);
    });
}

function sortList(id) { // extremely slow (do not use)
    const list = domById(id);
    let i, switching, b, shouldSwitch;
    switching = true;
    while (switching) {
        switching = false;
        b = list.getElementsByTagName('LI');
        for (i = 0; i < (b.length - 1); i++) {
            shouldSwitch = false;
            if (b[i].innerHTML.toLowerCase() > b[i + 1].innerHTML.toLowerCase()) {
                shouldSwitch = true;
                break;
            }
        }
        if (shouldSwitch) {
            b[i].parentNode.insertBefore(b[i + 1], b[i]);
            switching = true;
        }
    }
}

/**
 *  main livery list
 */
function listLiveries() {
    const livList = $('#liverylist').html('');
    const tempFrag = document.createDocumentFragment()
    , thumbsDir = noCommit + '/thumbs'
    , acftId = geofs.aircraft.instance.id
    , airplane = getCurrentAircraft(); // chained variable declarations
    $('#listDiv').attr('data-ac', acftId); // tells us which aircraft's liveries are loaded
    for (let i = 0; i < airplane.liveries.length; i++) {
        const e = airplane.liveries[i];
        if (e.disabled) continue;
        const listItem = $('<li/>', {id: [acftId, e.name, 'button'].join('_'), class: 'livery-list-item', "data-idx": i});
        listItem.append($('<span/>').text(e.name));
        listItem.toggleClass('offi', acftId < 100).toggleClass("geofs-visible", !geofs.preferences.liveryPotato); // if param2 is true, it'll add 'offi', if not, it will remove 'offi'
		acftId < 1000 && listItem.append($('<img/>', {loading: 'lazy', src: [thumbsDir, acftId, acftId + '-' + e.idx + '.png'].join('/')}));
        e.credits && e.credits.length && $('<small/>').text(`by ${e.credits}`).appendTo(listItem);
        $('<i/>', { id: acftId + "_" + e.name }).appendTo(listItem);
        listItem.appendTo(tempFrag);
    }
    livList.append(tempFrag);
    loadFavorites();
    loadAirlines();
    addCustomForm();
}

function loadFavorites() {
	const favorites = localStorage.getItem('favorites') ?? (localStorage.setItem('favorites', ''), ''); // sets favourites to '' if they can't be found and initialises localStorage.favorites
    $("#favorites").empty();
    const list = favorites.split(',');
    const airplane = geofs.aircraft.instance.id;
    list.forEach(function (e) {
        if ((airplane == e.slice(0, airplane.length)) && (e.charAt(airplane.length) == '_')) {
            star(domById(e));
        }
    });
}

function loadAirlines() {
    domById("airlinelist").innerHTML = '';
    const airplane = getCurrentAircraft();
    const textures = airplane.liveries[0].texture;
    airlineobjs.forEach(function(airline) {
        let airlinename = appendNewChild(domById('airlinelist'), 'li', {
            style: "color:" + airline.color + ";background-color:" + airline.bgcolor + "; font-weight: bold;"
        });
        airlinename.innerText = airline.name;
        let removebtn = appendNewChild(airlinename, "button", {
            class: "mdl-button mdl-js-button mdl-button--raised mdl-button",
            style: "float: right; margin-top: 6px; background-color: #9e150b;",
            onclick: `LiverySelector.removeAirline("${airline.url}")`
        });
        removebtn.innerText = "- Remove airline";
        if (Object.keys(airline.aircrafts).includes(geofs.aircraft.instance.id)) {
            airline.aircrafts[geofs.aircraft.instance.id].liveries.forEach(function (e, i) {
                let listItem = appendNewChild(domById('airlinelist'), 'li', {
                    id: [geofs.aircraft.instance.id, e.name, 'button'].join('_'),
                    class: 'livery-list-item'
                });
                if ((textures.filter(x => x === textures[0]).length === textures.length) && textures.length !== 1) { // the same texture is used for all indexes and parts
                    const texture = e.texture[0];
                    listItem.onclick = () => {
                        loadLivery(Array(textures.length).fill(texture), airplane.index, airplane.parts);
                        if (airplane.mp != 'disabled' && whitelist.includes(airline.url.trim())) {
                            setInstanceId({url: airline.url, idx: i});
                        }
                    }
                } else {
                    listItem.onclick = () => {
                        loadLivery(e.texture, airplane.index, airplane.parts, e.materials);
                        if (airplane.mp != 'disabled' && whitelist.includes(airline.url.trim())) {
                            setInstanceId({url: airline.url, idx: i});
                        }
                    }
                }
                listItem.innerHTML = createTag('span', { class: 'livery-name' }, e.name).outerHTML;
                if (e.credits && e.credits.length) {
                    listItem.innerHTML += `<small>by ${e.credits}</small>`;
                }
            });
        }
    });
}

function addCustomForm() {
    document.querySelector('#livery-custom-tab-upload .upload-fields').innerHTML = '';
    document.querySelector('#livery-custom-tab-direct .upload-fields').innerHTML = '';
    const airplane = getCurrentAircraft();
    const textures = airplane.liveries[0].texture.filter(t => typeof t !== 'object');
    const placeholders = airplane.labels;
    if (textures.length){
    if (textures.filter(x => x === textures[0]).length === textures.length) { // the same texture is used for all indexes and parts
        createUploadButton(placeholders[0]);
        createDirectButton(placeholders[0]);
    } else {
        placeholders.forEach((placeholder, i) => {
            createUploadButton(placeholder);
            createDirectButton(placeholder, i);
        });
    }
    }
    if (airplane.liveries[0].materials) {
        airplane.liveries[0].materials.forEach((material, key) => {
            let partlist = [];
            airplane.liveries[0].texture.forEach((e, k) => {
                if (typeof(e) === 'object'){
                    if (e.material == key){
                        partlist.push(airplane.parts[k]);
                    }
                }
            });
            createColorChooser(material.name, Object.keys(material)[1], partlist);
            createUploadColorChooser(material.name, Object.keys(material)[1], partlist);
        })
    }
    // click first tab to refresh button status
    document.querySelector('.livery-custom-tabs li').click();
}
function debounceSearch (func) {
    let timeoutId = null;
    return (text) => {
        clearTimeout(timeoutId);
		if (geofs.preferences.liveryPotato) return;
        timeoutId = setTimeout(() => {
            func(text);
        }, 250); // debounces for 250 ms
    };
}
const search = debounceSearch(text => {
	if (geofs.preferences.liveryPotato) return;
    const liveries = document.getElementById('liverylist').children; // .children is better than .childNodes
    if (text == '') {
		log("Potato mode: " + geofs.preferences.liveryPotato);
		for (const a of liveries) a.classList.toggle('geofs-visible', !geofs.preferences.liveryPotato);
		return;
    }
	console.log(text);
    text = text.toLowerCase(); // query string lowered here to avoid repeated calls
    for (let i = 0; i < liveries.length; i++) {
        const e = liveries[i]
        , v = e.classList.contains('geofs-visible')
        if (e.textContent.toLowerCase().includes(text)) { // textContent better than innerText
            if (!v) e.classList.add('geofs-visible');
        } else {
            if (v) e.classList.remove('geofs-visible');
        }
    };
});

function potatoSearch(text) {
	const liveries = document.getElementById('liverylist').children;
	if (text == '') {
		for (const a of liveries) a.classList.toggle('geofs-visible', false);
		return;
	}
    text = text.toLowerCase();
    for (let i = 0; i < liveries.length; i++) {
        const e = liveries[i]
        , v = e.classList.contains('geofs-visible');
		e.textContent.toLowerCase().includes(text) ? (v || e.classList.add('geofs-visible')) : (v && e.classList.remove('geofs-visible'));
    };
}

function changeMaterial(name, color, type, partlist){
    let r = parseInt(color.substring(1, 3), 16) / 255
    let g = parseInt(color.substring(3, 5), 16) / 255
    let b = parseInt(color.substring(5, 7), 16) / 255
    partlist.forEach(part => {
        geofs.aircraft.instance.definition.parts[part]['3dmodel']._model.getMaterial(name).setValue(type, new Cesium.Cartesian4(r, g, b, 1.0));
    });
}

/**
 * Mark as favorite
 *
 * @param {HTMLElement} element
 */
function star(element) {
    const e = element.classList;
    const elementId = [element.id, 'favorite'].join('_');
	let list = localStorage.getItem('favorites').split(',');
    if (e.contains("checked")) {
        domById('favorites').removeChild(domById(elementId));
        const index = list.indexOf(element.id);
        if (index !== -1) {
            list.splice(index, 1);
        }
        localStorage.setItem('favorites', list);
    } else {
		const btn = domById([element.id, 'button'].join('_'));
        const fbtn = appendNewChild(domById('favorites'), 'li', { id: elementId, class: 'livery-list-item' });
        // fbtn.onclick = btn.onclick; // moved to loadFavorites
        fbtn.innerText = btn.children[0].innerText;
		
        list.push(element.id);
        localStorage.setItem('favorites', [...new Set(list)]);
    }
    //style animation
    e.toggle('checked');
}

/**
 * @param {string} id
 */
function createUploadButton(id) {
    const customDiv = document.querySelector('#livery-custom-tab-upload .upload-fields');
    appendNewChild(customDiv, 'input', {
        type: 'file',
        onchange: 'LiverySelector.uploadLivery(this)'
    });
    appendNewChild(customDiv, 'input', {
        type: 'text',
        name: 'textureInput',
        class: 'mdl-textfield__input address-input',
        placeholder: id,
        id: id
    });
    appendNewChild(customDiv, 'br');
}

/**
 * @param {string} id
 * @param {number} i
 */
function createDirectButton(id, i) {
    const customDiv = document.querySelector('#livery-custom-tab-direct .upload-fields');
    appendNewChild(customDiv, 'input', {
        type: 'file',
        onchange: 'LiverySelector.loadLiveryDirect(this,' + i + ')'
    });
    appendNewChild(customDiv, 'span').textContent = id;
    appendNewChild(customDiv, 'br');
}

function createColorChooser(name, type, partlist) {
    const customDiv = document.querySelector('#livery-custom-tab-direct .upload-fields');
    appendNewChild(customDiv, 'input', {
        type: 'color',
        name: name,
        class: 'colorChooser',
        onchange: `changeMaterial("${name}", this.value, "${type}", [${partlist}])`
    });
    appendNewChild(customDiv, 'span', {style:'padding-top: 20px; padding-bottom: 20px;'}).textContent = name;
    appendNewChild(customDiv, 'br');
}


function createUploadColorChooser(name, type, partlist) {
    const customDiv = document.querySelector('#livery-custom-tab-upload .upload-fields');
    appendNewChild(customDiv, 'input', {
        type: 'color',
        name: "textureInput",
        id: name,
        class: 'colorChooser',
        onchange: `changeMaterial("${name}", this.value, "${type}", [${partlist}])`
    });
    appendNewChild(customDiv, 'span', {style:'padding-top: 20px; padding-bottom: 20px;'}).textContent = name;
    appendNewChild(customDiv, 'br');
}

/**
 * @param {HTMLInputElement} fileInput
 * @param {number} i
 */
function loadLiveryDirect(fileInput, i) {
    const reader = new FileReader();
    reader.addEventListener('load', (event) => {
        const airplane = getCurrentAircraft();
        const textures = airplane.liveries[0].texture;
        const newTexture = event.target.result;
        if (i === undefined) {
            loadLivery(Array(textures.length).fill(newTexture), airplane.index, airplane.parts);
        } else {
            geofs.api.changeModelTexture(
                geofs.aircraft.instance.definition.parts[airplane.parts[i]]["3dmodel"]._model,
                newTexture,
                { index: airplane.index[i] }
            );
        }
        fileInput.value = null;
    });
    // read file (if there is one)
    fileInput.files.length && reader.readAsDataURL(fileInput.files[0]);
}

/**
 * @param {HTMLInputElement} fileInput
 */
function uploadLivery(fileInput) {
    if (!fileInput.files.length)
        return;
    if (!localStorage.imgbbAPIKEY) {
        alert('No imgbb API key saved! Check API tab');
        fileInput.value = null;
        return;
    }
    const form = new FormData();
    form.append('image', fileInput.files[0]);
    if (localStorage.liveryAutoremove)
        form.append('expiration', (new Date() / 1000) * 60 * 60);

    const settings = {
        'url': `https://api.imgbb.com/1/upload?key=${localStorage.imgbbAPIKEY}`,
        'method': 'POST',
        'timeout': 0,
        'processData': false,
        'mimeType': 'multipart/form-data',
        'contentType': false,
        'data': form
    };

    $.ajax(settings).done(function (response) {
        const jx = JSON.parse(response);
        log(jx.data.url);
        fileInput.nextSibling.value = jx.data.url;
        fileInput.value = null;
        if (!uploadHistory[jx.data.id] || (uploadHistory[jx.data.id].expiration !== jx.data.expiration)) {
            uploadHistory[jx.data.id] = jx.data;
            localStorage.lsUploadHistory = JSON.stringify(uploadHistory);
        }
    });
}

function handleCustomTabs(e) {
    e = e || window.event;
    const src = e.target || e.srcElement;
    const tabId = src.innerHTML.toLocaleLowerCase();
    // iterate all divs and check if it was the one clicked, hide others
    domById('customDiv').querySelectorAll(':scope > div').forEach(tabDiv => {
        if (tabDiv.id != ['livery-custom-tab', tabId].join('-')) {
            tabDiv.style.display = 'none';
            return;
        }
        tabDiv.style.display = '';
        // special handling for each tab, could be extracted
        switch (tabId) {
            case 'upload': {
                const fields = tabDiv.querySelectorAll('input[type="file"]');
                fields.forEach(f => localStorage.imgbbAPIKEY ? f.classList.remove('err') : f.classList.add('err'));
                const apiKeys = !!localStorage.liveryDiscordId && !!localStorage.imgbbAPIKEY;
                tabDiv.querySelector('.livery-submit .api').style.display = apiKeys ? '' : 'none';
                tabDiv.querySelector('.livery-submit .no-api').style.display = apiKeys ? 'none' : '';
            } break;

            case 'download': {
                reloadDownloadsForm(tabDiv);
            } break;

            case 'api': {
                reloadSettingsForm();
            } break;
        }
    });

}

/**
 * reloads texture files for current airplane
 *
 * @param {HTMLElement} tabDiv
 */
function reloadDownloadsForm(tabDiv) {
    const airplane = getCurrentAircraft();
    const liveries = airplane.liveries;
    const defaults = liveries[0];
    const fields = tabDiv.querySelector('.download-fields');
    fields.innerHTML = '';
    liveries.forEach((livery, liveryNo) => {
        const textures = livery.texture.filter(t => typeof t !== 'object');
        if (!textures.length) return; // ignore material defs
        appendNewChild(fields, 'h7').textContent = livery.name;
        const wrap = appendNewChild(fields, 'div');
        textures.forEach((href, i) => {
            if (typeof href === 'object') return;
            if (liveryNo > 0 && href == defaults.texture[i]) return;
            const link = appendNewChild(wrap, 'a', {
                href, target: '_blank',
                class: "mdl-button mdl-button--raised mdl-button--colored"
            });
            link.textContent = airplane.labels[i];
        });
    });
}

/**
 * reloads settings form after changes
 */
function reloadSettingsForm() {
    const apiInput = domById('livery-setting-apikey');
    apiInput.placeholder = localStorage.imgbbAPIKEY ?
        'API KEY SAVED âœ“ (type CLEAR to remove)' :
        'API KEY HERE';

    const removeCheckbox = domById('livery-setting-remove');
    removeCheckbox.checked = (localStorage.liveryAutoremove == 1);

    const discordInput = domById('livery-setting-discordid');
    discordInput.value = localStorage.liveryDiscordId || '';
}

/**
 * saves setting, gets setting key from event element
 *
 * @param {HTMLElement} element
 */
function saveSetting(element) {
    const id = element.id.replace('livery-setting-', '');
    switch (id) {
        case 'apikey': {
            if (element.value.length) {
                if (element.value.trim().toLowerCase() == 'clear') {
                    delete localStorage.imgbbAPIKEY;
                } else {
                    localStorage.imgbbAPIKEY = element.value.trim();
                }
                element.value = '';
            }
        } break;

        case 'remove': {
            localStorage.liveryAutoremove = element.checked ? '1' : '0';
        } break;

        case 'discordid': {
            localStorage.liveryDiscordId = element.value.trim();
        } break;
    }
    reloadSettingsForm();
}

async function addAirline() {
    let url = prompt("Enter URL to the json file of the airline:");
    if (!links.includes(url)) {
        links.push(url);
        localStorage.links += `,${url}`
        await fetch(url).then(res => res.json()).then(data => airlineobjs.push(data));
        airlineobjs[airlineobjs.length - 1].url = url.trim();
        loadAirlines();
    } else {
        alert("Airline already added");
    }
}
function removeAirline(url) {
    removeItem(links, url.trim());
    if (links.toString().charAt(0) === ","){
        localStorage.links = links.toString().slice(1);
    } else {
        localStorage.links = links.toString();
    }
    airlineobjs.forEach(function (e, index) {
        if (e.url.trim() === url.trim()) {
            airlineobjs.splice(index, 1);
        }
    });
    loadAirlines();
}

/**
 * @returns {object} current aircraft from liveryobj
 */
function getCurrentAircraft() {
    return liveryobj.aircrafts[geofs.aircraft.instance.id];
}

function setInstanceId(id) {
    geofs.aircraft.instance.liveryId = id;
}

async function updateMultiplayer() {
    const users = Object.values(multiplayer.visibleUsers);

    const texturePromises = users.map(async u => {
        const liveryEntry = liveryobj.aircrafts[u.aircraft];
        let textures = [];

        let otherId = u.currentLivery;

        // if (!liveryEntry || !u.model || liveryEntry.mp == 'disabled') {
        if (!liveryEntry || !u.model) { // TODO change back, testing
            return; // without livery or disabled
        }

        if (mpLiveryIds[u.id] === otherId) {
            return; // already updated
        }

        mpLiveryIds[u.id] = otherId;

        if (otherId >= ML_ID_OFFSET && otherId < LIVERY_ID_OFFSET) {
            textures = getMLTexture(u, liveryEntry); // ML range 1kâ€“10k
        } else if (
            (otherId >= LIVERY_ID_OFFSET && otherId < LIVERY_ID_OFFSET * 2) ||
            typeof otherId === "object"
        ) {
            textures = await getMPTexture(u, liveryEntry); // LS range 10k+10k
        } else {
            return; // game-managed livery
        }

        textures.forEach(texture => {
            if (texture.material !== undefined) {
                applyMPMaterial(
                    u.model,
                    texture.material,
                    texture.type,
                    texture.color
                );
            } else {
                applyMPTexture(
                    texture.uri,
                    texture.tex,
                    img => u.model.changeTexture(img, { index: texture.index })
                );
            }
        });
    });

    await Promise.all(texturePromises); // wait for all user updates to complete
}


/**
 * Fetch and resize texture to expected format
 * @param {string} url
 * @param {sd} tex
 * @param {function} cb
 */
function applyMPTexture(url, tex, cb) {
    try {
        Cesium.Resource.fetchImage({ url }).then(img => {
            const canvas = createTag('canvas', { width: tex._width, height: tex._height });
            canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
            cb(canvas.toDataURL('image/png'));
        });
    } catch (e) {
        log(['LSMP', !!tex, url, e].join("\n"));
    }
}

function applyMPMaterial(model, name, type, color){
    model._model.getMaterial(name).setValue(type, new Cesium.Cartesian4(...color, 1.0));
}

/**
 * @param {object} u
 * @param {object} liveryEntry
 */
async function getMPTexture(u, liveryEntry) {
    const otherId = u.currentLivery - LIVERY_ID_OFFSET;
    const textures = [];
    log(u.currentLivery + ": " + typeof(u.currentLivery));
    // check model for expected textures
    const uModelTextures = u.model._model._rendererResources.textures;
    if (!u.currentLivery) return []; // early return in case of missing livery
    if (typeof(u.currentLivery) === "object") { //currentLivery is object -> virtual airline liveries
        log("VA detected");
        log(u.currentLivery);
        if ( mpAirlineobjs[u.currentLivery.url] === undefined) {
            await fetch(u.currentLivery.url).then(res => res.json()).then(data => mpAirlineobjs[u.currentLivery.url] = data);
            log(mpAirlineobjs[u.currentLivery.url]);
        }
        const texturePromises = liveryEntry.mp.map(async e => {
            if (e.textureIndex !== undefined) {
                return {
                    uri: mpAirlineobjs[u.currentLivery.url].aircrafts[u.aircraft].liveries[u.currentLivery.idx].texture[e.textureIndex],
                    tex: uModelTextures[e.modelIndex],
                    index: e.modelIndex
                };
            } else if (e.material !== undefined) {
                const mat = mpAirlineobjs[u.currentLivery.url].aircrafts[u.aircraft].liveries[u.currentLivery.idx].materials[e.material];
                const typeKey = Object.keys(mat)[1];
                return {
                    material: mat.name,
                    type: typeKey,
                    color: mat[typeKey]
                };
            } else if (e.mosaic !== undefined) {
                const mosaicTexture = await generateMosaicTexture(
                    e.mosaic.base,
                    e.mosaic.tiles,
                    mpAirlineobjs[u.currentLivery.url].aircrafts[u.aircraft].liveries[u.currentLivery.idx].texture
                );
                return {
                    uri: mosaicTexture,
                    tex: uModelTextures[e.modelIndex],
                    index: e.modelIndex
                };
            }
        });

        const resolvedTextures = await Promise.all(texturePromises);
        textures.push(...resolvedTextures);
    } else {
        const texturePromises = liveryEntry.mp.map(async e => {
            if (e.textureIndex !== undefined) {
                return {
                    uri: liveryEntry.liveries[otherId].texture[e.textureIndex],
                    tex: uModelTextures[e.modelIndex],
                    index: e.modelIndex
                };
            } else if (e.material !== undefined) {
                const mat = liveryEntry.liveries[otherId].materials[e.material];
                const typeKey = Object.keys(mat)[1];
                return {
                    material: mat.name,
                    type: typeKey,
                    color: mat[typeKey]
                };
            } else if (e.mosaic !== undefined) {
                const mosaicTexture = await generateMosaicTexture(
                    e.mosaic.base,
                    e.mosaic.tiles,
                    liveryEntry.liveries[otherId].texture
                );
                return {
                    uri: mosaicTexture,
                    tex: uModelTextures[e.modelIndex],
                    index: e.modelIndex
                };
            }
        });

        const resolvedTextures = await Promise.all(texturePromises);
        textures.push(...resolvedTextures);
    }
    log("getMPtexture\n" + textures);
    return textures;
}

/**
 * @param {object} u
 * @param {object} liveryEntry
 */
function getMLTexture(u, liveryEntry) {
    if (!mLiveries.aircraft) {
        fetch(atob(liveryobj.mapi)).then(data => data.json()).then(json => {
            Object.keys(json).forEach(key => mLiveries[key] = json[key]);
        });
        return [];
    }
    const liveryId = u.currentLivery - ML_ID_OFFSET;
    const textures = [];
    const texIdx = liveryEntry.labels.indexOf('Texture');
    if (texIdx !== -1) {
        textures.push({
            uri: mLiveries.aircraft[liveryId].mptx,
            tex: u.model._model._rendererResources.textures[liveryEntry.index[texIdx]],
            index: liveryEntry.index[texIdx]
        });
    }
    return textures;
}

async function generateMosaicTexture(url, tiles, textures) {
    const baseImage = await Cesium.Resource.fetchImage({ url });
    const canvas = new OffscreenCanvas(baseImage.width, baseImage.height);
    const ctx = canvas.getContext('2d');

    // Draw the base image first
    ctx.drawImage(baseImage, 0, 0, canvas.width, canvas.height);

    // Create an array of Promises for drawing all tiles
    const drawTilePromises = tiles.map(async (tile) => {
        const image = await Cesium.Resource.fetchImage({ url: textures[tile.textureIndex] });
        ctx.drawImage(
            image,
            tile.sx, tile.sy, tile.sw, tile.sh,
            tile.dx, tile.dy, tile.dw, tile.dh
        );
    });

    // Wait for all tiles to be drawn
    await Promise.all(drawTilePromises);

    // Now canvas is fully rendered; return the data URL
    log(canvas.toDataURL());
    return canvas.toDataURL('image/png');
}

/******************* Utilities *********************/

/**
 * @param {string} id Div ID to toggle, in addition to clicked element
 */
function toggleDiv(id) {
    var $e = $(`#${id}`);
	$e.toggle();
    $(window.event.target).toggleClass("closed", $e.css("display") === "none");
}

/**
 * Create tag with <name attributes=...
 *
 * @param {string} name
 * @param {Object} attributes
 * @param {string|number} content
 * @returns {HTMLElement}
 */
function createTag(name, attributes = {}, content = '') {
    const el = document.createElement(name);
    Object.keys(attributes || {}).forEach(k => el.setAttribute(k, attributes[k]));
    if (('' + content).length) {
        el.innerHTML = content;
    }
    return el;
}

/**
 * Creates a new element <tagName attributes=...
 * appends to parent and returns the child for later access
 *
 * @param {HTMLElement} parent
 * @param {string} tagName
 * @param {object} attributes
 * @param {number} pos insert in Nth position (default append)
 * @returns {HTMLElement}
 */
function appendNewChild(parent, tagName, attributes = {}, pos = -1) {
    const child = createTag(tagName, attributes);
    if (pos < 0) {
        parent.appendChild(child);
    } else {
        parent.insertBefore(child, parent.children[pos]);
    }

    return child;
}

function removeItem(array, itemToRemove) {
    const index = array.indexOf(itemToRemove);
    if (index !== -1) {
        array.splice(index, 1);
    }
}

/**
 * @param {string} elementId
 * @returns {HTMLElement}
 */
function domById(elementId) {
    return document.getElementById(elementId);
}

/******************* HTML & CSS Templates *********************/

/**
 * @returns {string} HTML template for main panel
 */
function generateListHTML() {
    return `
        <h3><img src="${noCommit}/liveryselector-logo.svg" class="livery-title" title="LiverySelector" /></h3>

        <div class="livery-searchbar mdl-textfield mdl-js-textfield geofs-stopMousePropagation geofs-stopKeyupPropagation">
            <input class="mdl-textfield__input address-input" type="text" placeholder="Search liveries" onkeyup="LiverySelector.search(this.value)" id="searchlivery">
            <label class="mdl-textfield__label" for="searchlivery">Search liveries</label>
			<button class="potato-mode-search">search</button>
        </div>
		<div style="width: 100%">
			<span>Potato mode: </span><input id="livery-potato-mode" data-gespref="geofs.preferences.liveryPotato" type="checkbox"></input>
		</div>
        <h6 onclick="LiverySelector.toggleDiv('favorites')">Favorited Liveries</h6>
        <ul id="favorites" class="geofs-list geofs-visible"></ul>

        <h6 onclick="LiverySelector.toggleDiv('liverylist')">Available Liveries</h6>
        <ul id="liverylist" class="geofs-list geofs-visible"></ul>

        <h6 onclick="LiverySelector.toggleDiv('airlinelist')">Virtual Airlines</h6><button class="mdl-button mdl-js-button mdl-button--raised mdl-button" style="background-color: #096628; color: white;" onclick="LiverySelector.addAirline()">+ Add Airline</button>
        <ul id="airlinelist" class="geofs-list geofs-visible"></ul>

        <h6 onclick="LiverySelector.toggleDiv('customDiv')" class="closed">Load External Liveries</h6>
        <div id="customDiv" class="mdl-textfield mdl-js-textfield geofs-stopMousePropagation geofs-stopKeyupPropagation" style="display:none;">
            <ul class="livery-custom-tabs" onclick="LiverySelector.handleCustomTabs()">
                <li>Upload</li>
                <li>Direct</li>
                <li>Download</li>
                <li>API</li>
            </ul>
            <div id="livery-custom-tab-upload" style="display:none;">
                <div>Paste URL or upload image to generate ImgBB URL</div>
                <div class="upload-fields"></div>
                <div><button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" onclick="LiverySelector.inputLivery()">Load livery</button></div>
                <div class="livery-submit geofs-list-collapsible-item">Contribute to the LiverySelector Database
                    <div class="geofs-collapsible no-api">-&gt; Enter your ImgBB API Key and Discord User ID in the API tab.</div>
                    <div class="geofs-collapsible api">
                        <label for="livery-submit-liveryname">Livery Name</label>
                        <input type="text" id="livery-submit-liveryname" class="mdl-textfield__input address-input">
                        <label for="livery-submit-credits">Author</label>
                        <input type="text" id="livery-submit-credits" class="mdl-textfield__input address-input">
                        <input type="checkbox" id="livery-submit-confirm-perms">
                        <label for="livery-submit-confirm-perms">I am the author and have created the textures myself, or have permission from the author to use those textures.</label><br>
                        <input type="checkbox" id="livery-submit-confirm-legal">
                        <label for="livery-submit-confirm-legal">I confirm the textures are safe for all ages and audiences, non-offensive, appropriate, high-quality, and don't violate any laws or other regulations.</label>
                        <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" onclick="LiverySelector.submitLivery()">Submit livery for review</button>
                        <small>
                          Join our <a href="https://discord.gg/2tcdzyYaWU" target="_blank">Discord</a> to follow up on your contributions.
                          By submitting the livery, you agree to the <a href="https://discord.com/terms" target="_blank">Discord Terms of Service</a> and our Discord server rules. Failing to comply may result in your submissions being ignored.
                        </small>
                    </div>
                </div>
            </div>
            <div id="livery-custom-tab-direct" style="display:none;">
                <div>Load texture directly in client, no upload.</div>
                <div class="upload-fields"></div>
            </div>
            <div id="livery-custom-tab-download" style="display:none;">
                <div>Download textures for current aircraft:</div>
                <div class="download-fields"></div>
            </div>
            <div id="livery-custom-tab-api" style="display:none;">
              <div>
                <label for="livery-setting-apikey">Paste your imgbb API key here (<a href="https://api.imgbb.com" target="_blank">get key</a>)</label>
                <input type="text" id="livery-setting-apikey" class="mdl-textfield__input address-input" onchange="LiverySelector.saveSetting(this)">
                <input type="checkbox" id="livery-setting-remove" onchange="LiverySelector.saveSetting(this)">
                <label for="livery-setting-remove">Expire links after one hour<br><small>(only for testing, disable when submitting to the database!)</small></label>
                <label for="livery-setting-discordid">Discord User ID (<a href="https://support.discord.com/hc/en-us/articles/206346498" target="_blank">howto</a>)</label>
                <input type="number" id="livery-setting-discordid" class="mdl-textfield__input address-input" onchange="LiverySelector.saveSetting(this)">
              </div>
            </div>
        </div>
        <br/>
        <a href="https://github.com/kolos26/GEOFS-LiverySelector/tree/main/tutorial" target="_blank"><button class="mdl-button mdl-js-button mdl-button--raised mdl-button">Open Tutorial</button></a><br/>
        <a href="https://discord.gg/2tcdzyYaWU" target="_blank"><button class="mdl-button mdl-js-button mdl-button--raised mdl-button">Join Our Discord</button></a><br/>
        <a href="https://github.com/kolos26/GEOFS-LiverySelector" target="_blank"><button class="mdl-button mdl-js-button mdl-button--raised mdl-button">Visit our Github page</button></a><br/>
        <a href="mailto:LiverySelector20220816@gmail.com" target="_blank"><button class="mdl-button mdl-js-button mdl-button--raised mdl-button">Contact Us: LiverySelector20220816@gmail.com</button></a><br/>
`;
}

/**
 * @returns {HTMLElement} HTML template for main menu livery button
 */
function generatePanelButtonHTML() {
    const liveryButton = createTag('button', {
        title: 'Change livery',
        id: 'liverybutton',
        onclick: 'LiverySelector.togglePanel()',
        class: 'mdl-button mdl-js-button geofs-f-standard-ui geofs-mediumScreenOnly',
        'data-toggle-panel': '.livery-list',
        'data-tooltip-classname': 'mdl-tooltip--top',
        'data-upgraded': ',MaterialButton'
    });
    liveryButton.innerHTML = createTag('img', { src: `${noCommit}/liveryselector-logo-small.svg`, height: '30px' }).outerHTML;

    return liveryButton;
}

function togglePanel() {
    const p = document.getElementById('listDiv');
    console.time('listLiveries');
	try {
    	p.dataset.ac != geofs.aircraft.instance.id && window.LiverySelector.listLiveries();
	} catch (e) {
		log(e, "error");
	}
	console.timeEnd('listLiveries');
}

window.LiverySelector = {
    liveryobj,
    saveSetting,
    toggleDiv,
    loadLivery,
    loadLiveryDirect,
    handleCustomTabs,
    listLiveries,
    star,
    search,
    inputLivery,
    uploadLivery,
    submitLivery,
    uploadHistory,
    loadAirlines,
    addAirline,
    removeAirline,
    airlineobjs,
	setInstanceId,
    togglePanel,
	log,
	potatoSearch,
};
// ==UserScript==
// @name         GeoFS Taxiway Lights
// @version      0.8.1
// @description  Adds taxiway lights using OSM data (https://www.openstreetmap.org/copyright)
// @author       GGamerGGuy
// @match        https://geo-fs.com/geofs.php*
// @match        https://*.geo-fs.com/geofs.php*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=geo-fs.com
// @grant        none
// @downloadURL  https://github.com/tylerbmusic/GeoFS-Taxiway-Lights/raw/refs/heads/main/userscript.js
// @updateURL    https://github.com/tylerbmusic/GeoFS-Taxiway-Lights/raw/refs/heads/main/userscript.js
// ==/UserScript==
(function() {
    'use strict';
    window.twLights = [];
    window.errs = 0;
    window.twLC = {
        oldChunks: [],
        newChunks: [],
        toAdd: [],
        toRemove: []
    };
    if (!window.gmenu || !window.GMenu) {
        console.log("Taxiway Lights getting GMenu");
        fetch('https://raw.githubusercontent.com/tylerbmusic/GeoFS-Addon-Menu/refs/heads/main/addonMenu.js')
            .then(response => response.text())
            .then(script => {eval(script);})
            .then(() => {setTimeout(afterGMenu, 100);});
    } else afterGMenu()
    async function afterGMenu() {
        const twLM = new window.GMenu("Taxiway Lights", "twL");
        twLM.addItem("Update Interval (seconds): ", "UpdateInterval", "number", 0, '5');
        twLM.addItem("Green/Yellow Light Size: ", "GSize", "number", 0, "0.05");
        twLM.addItem("Blue Light Size: ", "BSize", "number", 0, "0.07");
        console.log("TwL Enabled? " + localStorage.getItem("twLEnabled"));
        setTimeout(() => {window.updateLights();}, 100*Number(localStorage.getItem("twLUpdateInterval")));
        //Update notification
        async function checkForUpdates() {
            let NAME = "Taxiway-Lights";
            let SPACEDNAME = "Taxiway Lights";
            let VERSION = "0.8.1";
            let LSNAME = "twL";
            let URL = "https://github.com/tylerbmusic/GeoFS-Taxiway-Lights";
            let a = await fetch('https://tylerbmusic.github.io/versions.json?t=' + Date.now());
            let b = await a.text();
            let newversion = JSON.parse(b)[NAME];
            if (localStorage.getItem(LSNAME + "U" + VERSION) !== "true") { //Send an event upon updating (update data not available to the public)
                localStorage.setItem(LSNAME + "U" + VERSION, "true");
                await fetch(`https://track.tylerbialowas-bard.workers.dev?event=${LSNAME}v${VERSION}`, {method: "HEAD"});
            }
            if (newversion !== VERSION && localStorage.getItem(LSNAME + "StopU" + newversion) !== "true") {
                if (confirm(`A new update for ${SPACEDNAME} is available at ${URL}\nCurrent version: v${VERSION}; New version: v${newversion}\nPress "OK" open update URL in new tab, or "Cancel" to skip this update.`)) {
                    window.open(URL);
                    console.log("OPENING " + URL);
                } else {
                    localStorage.setItem(LSNAME + "StopU" + newversion, true);
                }
            }
        }
        checkForUpdates();
        //ANONYMOUS TRACKING VIA CLOUDFLARE (I will never sell your data.)
        //What's being tracked: For each script, how many hits (page loads) it's had in the last 24 hours, how many total hits in the last 30 days, and how many unique users there are.
        //Why it's being tracked: I am curious to know how many people are using my addons.
        //To see the data, go to https://track.tylerbialowas-bard.workers.dev in a web browser.

        if (true) { //To opt out of anonymous tracking, change the word "true" in this line to "false".
            const SCRIPT_NAME = "Taxiway_Lights";

            // Generate persistent ID
            let userId = localStorage.getItem("myScriptUserId");

            if (!userId) {
                userId = crypto.randomUUID();
                localStorage.setItem("myScriptUserId", userId);
            }
            try {
                const response = await fetch("https://track.tylerbialowas-bard.workers.dev", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        script: SCRIPT_NAME,
                        userId: userId
                    }),
                });

                if (response.ok) {
                    console.log("Analytics event sent successfully");
                }
            } catch (error) {
                console.error("Failed to track event:", error);
            }
        }
    }
})();
function fpe(num) {
    return Number(num.toFixed(3));
}

window.updateLights = async function() {
    if (window.geofs.cautiousWithTerrain == false && (localStorage.getItem("twLEnabled") == 'true')) { //timeRatio is basically how bright the terrain should be--at noon it's 0, at midnight it's 1
        let chunkSize = 0.04;
        let renderDist = 3;
        function chunkTick() {
            //Chunks creation
            let lla = window.geofs.aircraft.instance.llaLocation;
            window.twLC.newChunks = [];
            for (let v = -renderDist; v <= renderDist; v++) {
                let arr = [];
                for (let h = -renderDist; h <= renderDist; h++) {
                    arr.push({min: [fpe(Math.floor(lla[0]/chunkSize)*chunkSize + v*chunkSize), fpe(Math.floor(lla[1]/chunkSize)*chunkSize + h*chunkSize)], max: [fpe(Math.floor(lla[0]/chunkSize)*chunkSize + (v+1)*chunkSize), fpe(Math.floor(lla[1]/chunkSize)*chunkSize + (h+1)*chunkSize)]});
                }
                window.twLC.newChunks.push(arr);
            }
            //Testing new/old chunks
            if (JSON.stringify(window.twLC.newChunks) == JSON.stringify(window.twLC.oldChunks)) {
                return;
            }
            window.twLC.toAdd = [];
            window.twLC.toRemove = [];
            //To Add
            for (let a = 0; a < window.twLC.newChunks.length; a++) {
                for (let b = 0; b < window.twLC.newChunks.length; b++) {
                    if (JSON.stringify(window.twLC.oldChunks).indexOf(JSON.stringify(window.twLC.newChunks[a][b])) == -1) { //If it hadn't existed before, it's new
                        window.twLC.toAdd.push([a,b]);
                    }
                    if ((window.twLC.oldChunks[a] && window.twLC.oldChunks[a][b]) && JSON.stringify(window.twLC.newChunks).indexOf(JSON.stringify(window.twLC.oldChunks[a][b])) == -1) { //If it doesn't exist anymore, it's old
                        window.twLC.toRemove.push([a,b]);
                    }
                }
            }
            for (let f in window.twLC.toRemove) {
                let bds = window.twLC.oldChunks[window.twLC.toRemove[f][0]][window.twLC.toRemove[f][1]];
                let bound = `${fpe(bds.min[0])}, ${fpe(bds.min[1])}, ${fpe(bds.max[0])}, ${fpe(bds.max[1])}`;
                for (let l in window.twLights[bound]) {
                    window.geofs.api.viewer.entities.remove(window.twLights[bound][l]);
                }
                delete window.twLights[bound];
            }
            function addTheStuff(e) {
                if (e == window.twLC.toAdd.length) {
                    return;
                }
                console.log("adding " + e);
                let bds = window.twLC.newChunks[window.twLC.toAdd[e][0]][window.twLC.toAdd[e][1]]; //bounds, no formatting
                let bound = `${fpe(bds.min[0])}, ${fpe(bds.min[1])}, ${fpe(bds.max[0])}, ${fpe(bds.max[1])}`;
                if (e == 45) {
                    console.log([window.twLC.newChunks, window.twLC.oldChunks]);
                }
                window.getTwD(bound, bound); //getTaxiwayData
                setTimeout(() => {window.getTwDE(bound, bound)}, 150); //getTaxiwayDataEdgeless
                setTimeout(() => {addTheStuff(e+1)},300); //Private.coffee doesn't want more than 10 requests per second; I added this to give some time between requests.
            }
            addTheStuff(0);
            window.twLC.oldChunks = window.twLC.newChunks;
        }
        chunkTick();
    } else if ((localStorage.getItem("twLEnabled") != 'true')) {
        window.lastBounds = "";
        //for (let i in window.twLights) {
        //    window.geofs.api.viewer.entities.remove(window.twLights[i]);
        //}
        //window.twLights = [];
        //console.log("It's either daytime or the taxiway lights aren't enabled, lights are off");
    }
    setTimeout(() => {window.updateLights();}, 1000*Number(localStorage.getItem("twLUpdateInterval")));
}

function calculateBearing(lon1, lat1, lon2, lat2) {
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const lat1Rad = lat1 * Math.PI / 180;
    const lat2Rad = lat2 * Math.PI / 180;

    const y = Math.sin(dLon) * Math.cos(lat2Rad);
    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
          Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);

    const bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360; // Normalize to 0-360 degrees
}

// Function to calculate the offset points based on the bearing.
function calculateOffsetPoint(lon, lat, bearing, offsetDistance) {
    const R = 6378137; // Earth's radius in meters

    // Convert bearing to radians
    const bearingRad = (bearing + 90) * Math.PI / 180; // +90 to make it perpendicular

    // Calculate offset in radians
    const dLat = offsetDistance * Math.cos(bearingRad) / R;
    const dLon = offsetDistance * Math.sin(bearingRad) / (R * Math.cos(Math.PI * lat / 180));

    return {
        lonPlus: lon + dLon * 180 / Math.PI,
        latPlus: lat + dLat * 180 / Math.PI,
        lonMinus: lon - dLon * 180 / Math.PI,
        latMinus: lat - dLat * 180 / Math.PI
    };
}

function interpolatePoints(start, end, interval) {
    const [lon1, lat1] = start;
    const [lon2, lat2] = end;

    const distance = Math.sqrt(
        Math.pow(lon2 - lon1, 2) + Math.pow(lat2 - lat1, 2)
    );

    const numPoints = Math.max(Math.floor(distance / interval), 1);
    const interpolated = [];

    for (let i = 0; i <= numPoints; i++) {
        const ratio = i / numPoints;
        const lon = lon1 + (lon2 - lon1) * ratio;
        const lat = lat1 + (lat2 - lat1) * ratio;
        interpolated.push([lon, lat, 0]);
    }

    return interpolated;
}

async function getTaxiwayData(bounds) {
    const overpassUrl = 'https://overpass.private.coffee/api/interpreter';
    const query = `
        [out:json];
        (
            way["aeroway"="taxiway"]({{bbox}})[ref];
        );
        out body;
        >;
        out skel qt;
    `;
    const bbox = bounds;

    try {
        const response = await fetch(overpassUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Project-Name": "GeoFS Taxiway Lights",
                "From": "https://tylerbmusic.github.io/contact"
            },
            body: "data=" + encodeURIComponent(query.replace('{{bbox}}', bbox))
        });
        const data = await response.json();

        const taxiwayEdges = [];
        const nodes = {};

        data.elements.forEach(element => {
            if (element.type === 'node') {
                nodes[element.id] = element;
            }
        });

        data.elements.forEach(element => {
            if (element.type === 'way') {
                const wayNodes = element.nodes.map(nodeId => {
                    const node = nodes[nodeId];
                    if (node) {
                        return [node.lon, node.lat, 0];
                    }
                }).filter(Boolean);

                if (wayNodes.length > 1) {
                    const edgePoints = [];
                    const interval = 0.0002 + ((Math.random()-0.5)*0.00005); // Adjust for desired spacing

                    for (let i = 0; i < wayNodes.length - 1; i++) {
                        const segmentPoints = interpolatePoints(wayNodes[i], wayNodes[i + 1], interval);
                        const bearing = calculateBearing(
                            wayNodes[i][0], wayNodes[i][1],
                            wayNodes[i + 1][0], wayNodes[i + 1][1]
                        );

                        // Calculate edge points for each interpolated point
                        const offset = 10; // 10 meters from centerline
                        const interpolatedEdgePoints = segmentPoints.map(([lon, lat, alt]) => {
                            const offsetPoints = calculateOffsetPoint(lon, lat, bearing, offset);
                            return [
                                [offsetPoints.lonPlus, offsetPoints.latPlus, alt],
                                [offsetPoints.lonMinus, offsetPoints.latMinus, alt]
                            ];
                        });

                        edgePoints.push(...interpolatedEdgePoints);
                    }

                    taxiwayEdges.push(edgePoints);
                }
            }
        });

        return taxiwayEdges;
    } catch (error) {
        console.error('Error fetching taxiway data:', error);
    }
}

///
async function getTaxiwayDataEdgeless(bounds) {
    const overpassUrl = 'https://overpass.private.coffee/api/interpreter';
    const query = `
        [out:json];
        (
            way["aeroway"="taxiway"]({{bbox}});
        );
        out body;
        >;
        out skel qt;
    `;
    const bbox = bounds;

    try {
        const response = await fetch(overpassUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Project-Name": "GeoFS Taxiway Lights",
                "From": "https://tylerbmusic.github.io/contact"
            },
            body: "data=" + encodeURIComponent(query.replace('{{bbox}}', bbox))
        });
        const data = await response.json();

        const centerlinePoints = [];
        const nodes = {};

        data.elements.forEach(element => {
            if (element.type === 'node') {
                nodes[element.id] = element;
            }
        });

        data.elements.forEach(element => {
            if (element.type === 'way') {
                const wayNodes = element.nodes.map(nodeId => {
                    const node = nodes[nodeId];
                    if (node) {
                        return [node.lon, node.lat, 0];
                    }
                }).filter(Boolean);

                if (wayNodes.length > 1) {
                    const interval = 0.00007 + ((Math.random()-0.5)*0.00002); // Semi-random spacing

                    for (let i = 0; i < wayNodes.length - 1; i++) {
                        const segmentPoints = interpolatePoints(wayNodes[i], wayNodes[i + 1], interval);
                        centerlinePoints.push(...segmentPoints);
                    }
                }
            }
        });

        return centerlinePoints;
    } catch (error) {
        console.error('Error fetching taxiway data:', error);
    }
}
window.getTwD = async function(bounds, id) {
    getTaxiwayData(bounds).then(edges => {
        if (edges && edges.length && edges.length > 0) {
            edges.forEach(edge => {
                edge.forEach(([plus, minus]) => {
                    [plus, minus].forEach(epos => {
                        const apos = window.geofs.getGroundAltitude([epos[1], epos[0], epos[2]]).location;
                        apos[2] += 0.3556; //Offset 14 inches from the ground
                        const pos = window.Cesium.Cartesian3.fromDegrees(apos[1], apos[0], apos[2]);
                        if (pos[2] < 0) {
                            window.errs++;
                            pos[2] = 0 - pos[2];
                        }
                        if (!window.twLights[id]) {
                            window.twLights[id] = [];
                        }
                        window.twLights[id].push(
                            window.geofs.api.viewer.entities.add({
                                position: pos,
                                billboard: {
                                    image: "https://tylerbmusic.github.io/GPWS-files_geofs/bluelight.png",
                                    scale: Number(localStorage.getItem("twLBSize")) * (1 / window.geofs.api.renderingSettings.resolutionScale),
                                    scaleByDistance: { //May or may not work
                                        "near": 1,
                                        "nearValue": 0.5,
                                        "far": 1500,
                                        "farValue": 0.2
                                    },
                                    translucencyByDistance: new window.Cesium.NearFarScalar(10, 0.6, 10e3, 0.1)
                                },
                            }));
                    });
                });
            });
        }
    });
};

///
function checkProximityToRunway(pos) {
    // Retrieve and cache nearest runway if not already cached
    if (!window.runwayThresholds) {
        window.runwayThresholds = [];
        for (var i in window.geofs.runways.nearRunways) {
            const nearestRunway = window.geofs.runways.nearRunways[i];
            const l0 = nearestRunway.threshold1;
            const l1 = nearestRunway.threshold2;
            window.runwayThresholds.push(interpolatePoints([l0[1], l0[0]], [l1[1], l1[0]], 5 / 111000));
        }
    }

    const distSquared = (40 / 111000) ** 2; // Square distance to avoid sqrt calculations
    const posLon = pos[0];
    const posLat = pos[1];

    // Check if any point along the runway centerline is within the set proximity distance
    for (var v in window.runwayThresholds) {
        if (window.runwayThresholds[v].some(([lon, lat]) => {
            const deltaLon = lon - posLon;
            const deltaLat = lat - posLat;
            return deltaLon ** 2 + deltaLat ** 2 < distSquared;
        })) {
            return true; // Return true if any point is within proximity
        }
    }
    return false; // Return false if no points were close enough
}
///

window.getTwDE = async function(bounds, id) {
    getTaxiwayDataEdgeless(bounds).then(centerline => {
        var z = 0;
        if (centerline && centerline.length && centerline.length > 0) {
            centerline.forEach(epos => {
                z++;
                const apos = window.geofs.getGroundAltitude([epos[1], epos[0], epos[2]]).location;
                apos[2] += 0.3556; //Offset 14 inches from the ground
                const pos = window.Cesium.Cartesian3.fromDegrees(apos[1], apos[0], apos[2]);

                // Calculate distance to runway and set light color accordingly
                const isNearRunway = checkProximityToRunway(epos); // Calculate proximity
                const lightImage = (z%2 == 0 && isNearRunway) ?
                      "https://tylerbmusic.github.io/GPWS-files_geofs/yellowlight.png" :
                "https://tylerbmusic.github.io/GPWS-files_geofs/greenlight.png";

                if (pos[2] < 0) {
                    window.errs++;
                    pos[2] = 0 - pos[2];
                }
                if (!window.twLights[id]) {
                    window.twLights[id] = [];
                }
                window.twLights[id].push(
                    window.geofs.api.viewer.entities.add({
                        position: pos,
                        billboard: {
                            image: lightImage,
                            scale: Number(localStorage.getItem("twLGSize")) * (1 / window.geofs.api.renderingSettings.resolutionScale),
                            scaleByDistance: {
                                "near": 1,
                                "nearValue": 0.5,
                                "far": 2000,
                                "farValue": 0.2
                            },
                            translucencyByDistance: new window.Cesium.NearFarScalar(10, 0.6, 10e3, 0.1)
                        },
                    })
                );
            });
        }
    });
};
let debug = !1,
	version = "Release 2.0c";
async function multiliveries() {
	console.log("loading...");
	let e, i, t = {
			window: void 0,
			opened: !1
		},
		o = !1,
		a = 0,
		n = !1;
	await fetch("https://raw.githubusercontent.com/Spice9/Geofs-Multiliveries/main/dependencies/liveries.json").then((e => e.json())).then((i => e = i));
	void 0 === window.localStorage.mlFavorites && (window.localStorage.mlFavorites = []);
	let s = window.localStorage.mlFavorites.split(","),
		r = document.createElement("div"),
		l = document.createElement("i");

	function c(i, t) {
		var o = i + 1e3;
		if (debug && console.log("Livery Change Request as '" + i + "'"), t) n = !0,
			function(e, i) {
				let t = new geofs.api.Canvas({
						width: 500
					}),
					o = t.context,
					a = new Image;
				a.src = i, a.crossOrigin = "anonymous", a.onload = function() {
					t.canvas.width = a.width, t.canvas.height = a.height, o.drawImage(a, 0, 0);
					let n = new Image;
					n.src = "https://138772948-227015667470610340.preview.editmysite.com/uploads/1/3/8/7/138772948/overlay__1_.png", n.crossOrigin = "anonymous", n.onload = function() {
						o.globalAlpha = .25;
						let a = .25 * n.width,
							s = .25 * n.height;
						for (let i = -Math.abs(e); i < t.canvas.height; i += s)
							for (let r = -Math.abs(e); r < t.canvas.width; r += a) o.drawImage(n, r, i, a, s);
						let r = t.canvas.toDataURL("image/png");
						if (debug && console.log(r), 4140 != geofs.aircraft.instance.id) geofs.api.setModelTextureFromCanvas(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, t, 0);
						else {
							if (i.toString().includes("|")) {
								var l = i.split("|"),
									c = l[1],
									d = l[2];
								geofs.api.changeModelTexture(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, c, 2), geofs.api.changeModelTexture(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, d, 0), i = l[0]
							}
							geofs.api.setModelTextureFromCanvas(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, t, 1)
						}
					}
				}
			}(a, i), debug && console.log("livery changed to " + i);
		else if (i = e.aircraft[i].livery, n = !1, i.toString().includes("https://")) {
			if (4140 == geofs.aircraft.instance.id) {
				if (i.toString().includes("|")) {
					var s = i.split("|"),
						r = s[1],
						l = s[2];
					geofs.api.changeModelTexture(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, r, 2), geofs.api.changeModelTexture(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, l, 0), i = s[0]
				}
				return void geofs.api.changeModelTexture(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, i, 1)
			}
			geofs.api.changeModelTexture(geofs.aircraft.instance.definition.parts[0]["3dmodel"]._model, i, 0), debug && console.log("livery changed to " + i)
		} else geofs.aircraft.instance.loadLivery(i), debug && console.log("livery changed to " + i);
		geofs.aircraft.instance.liveryId = o
	}
	r.id = "mlButton", r.className = "mdl-button mdl-js-button", r.innerText = "Multiliveries ", l.className = "material-icons geofs-ui-bottom-icon", l.innerText = "flight_land", r.appendChild(l), r.addEventListener("click", (function() {
		if ("object" == typeof t.window && t.window.closed && (t.opened = !1), t.opened) return ui.notification.show("Panel is open in another window"), void(debug && console.log("Duplicate open attempt"));
		t.window = window.open("https://ariakim-taiyo.github.io/MLUI/", "_blank", "height=1000,width=1500"), setTimeout((function() {
			t.window.postMessage({
				type: "favorites",
				favorites: s
			}, "*")
		}), 2e3), t.opened = !0, t.window && !t.window.closed && void 0 !== t.window.closed || (ui.notification.show("Please allow popups on GeoFS"), debug && console.log("No Popup Permission"), t.opened = !1)
	})), 0 == document.getElementsByClassName("fmc-btn").length ? document.getElementsByClassName("geofs-ui-bottom")[0].appendChild(r) : document.getElementsByClassName("fmc-prog-info")[0].appendChild(r), document.querySelectorAll("[data-aircraft]").forEach((function(i) {
		e.ids.forEach((function(e) {
			i.dataset.aircraft.includes(e) && (i.style.background = "linear-gradient(90deg, rgba(0,212,255,1) 0%, rgba(255,255,255,1) 15%, rgba(255,255,255,1) 100%)", i.innerHTML.includes("Multiliveries") || (i.innerHTML = i.innerHTML + " [Multiliveries Frame]"))
		}))
	})), window.addEventListener("message", (e => {
		if (e = e.data, debug && console.log(e), "livery" === e.type && (e.custom ? c(e.livery, !0) : c(e.livery, !1)), "vehicle" === e.type && geofs.aircraft.instance.change(e.definition, null), "invalid" === e.type) return console.log("Invalid client, please use the original code."), void ui.notification.show("Invalid client, please use the original code.");
		"test" === e.type && t.window.postMessage({
			type: "answer",
			payload: multiliveries.toString()
		}, "*"), "offset" === e.type && (a = e.offset, n && c(e.livery, !0)), "favorites" === e.type && (s = e.favorites, window.localStorage.mlFavorites = s.join())
	})), geofs.aircraft.Aircraft.prototype.change = function(e, i, o, a) {
		var n = this;
		if (e = e || this.aircraftRecord.id, o = this.load(e, this.getCurrentCoordinates(), o, a), isNaN(parseInt(e)) ? n.loadLivery(i) : o.then((function() {
				n.loadLivery(i)
			})), void 0 !== t) return isNaN(parseInt(e)) ? (geofs.api.analytics.event("aircraft", "EXTERNAL AIRCRAFT"), o) : (geofs.api.analytics.event("aircraft", geofs.aircraftList[e].name), o)
	}, geofs.aircraft.Aircraft.prototype.load = function(i, t, a, n) {
		if (!isNaN(parseInt(i)) || void 0 === e) {
			o = !1;
			r = this;
			var s = geofs.aircraftList[i] && geofs.aircraftList[i].local ? geofs.aircraftList[i].path + "aircraft.json" : "/models/aircraft/load.php";
			if (void 0 === o) return;
			return new Promise((function(e, o) {
				r.id != i || a ? (geofs.doPause(1), r.unloadAircraft(), $.ajax(s, {
					data: {
						id: i,
						kc: geofs.killCache
					},
					dataType: "text",
					success: function(o, s, l) {
						if ("error" != s) {
							geofs.aircraftList[i] && geofs.aircraftList[i].local && (o = JSON.stringify({
								id: i,
								name: geofs.aircraftList[i].name,
								fullPath: geofs.aircraftList[i].path,
								isPremium: !1,
								isCommunity: !1,
								definition: btoa(o)
							}));
							var c = r.parseRecord(o)
						}
						c ? (geofs.aircraftList[i] && !geofs.aircraftList[i].local && (r.fullPath = r.aircraftRecord.fullPath), r.id = i, r.init(c, t, a, n)) : r.loadDefault("Could not load aircraft file"), e()
					},
					error: function(e, t, a) {
						i != geofs.aircraft.default && r.loadDefault("Could not load aircraft file" + a), o()
					}
				})) : e()
			}))
		}
		var r;
		o = !0, (r = this).unloadAircraft();
		var l = r.parseRecord(JSON.stringify({
			id: 42069,
			name: "EXTERNAL AIRCRAFT",
			fullPath: "EXTERNAL AIRCRAFT",
			isPremium: 1,
			isCommunity: !1,
			definition: i
		}));
		setTimeout((function() {
			r.init(l, t, a, n)
		}), 1e3)
	}, geofs.aircraft.Aircraft.prototype.addParts = function(e, i, t, n) {
		for (geofs.aircraft.instance.parts = {}, t = t || 1, n = 0; n < e.length; n++) {
			var s = e[n];
			if (s.include) {
				var r = geofs.includes[s.include];
				$.extend(!0, s, r[0]);
				for (var l = 1; l < r.length; l++) {
					var c = Object.assign({}, r[l], {
						parent: s.name
					});
					c.name = s.name + c.name, e.push(c)
				}
			}
			if (s.indices && 0 < s.indices) {
				for (l = 2; l <= s.indices; l++)(c = Object.assign({}, s, {
					indices: null
				})).name = s.name + l, c.node += l, e.push(c);
				s.name += "1", s.node += "1"
			}
		}
		if (void 0 !== a) {
			for (n = 0; n < e.length; n++) {
				for ((s = e[n]).points = s.points || {}, s.type = s.type || !1, s.brakesController = s.brakesController || !1, s.animations = s.animations || [], geofs.aircraft.instance.parts[s.name] = s, geofs.aircraft.instance.addOffsets(s, t), s.forceDirection && (s.forceDirection = AXIS_TO_INDEX[s.forceDirection]), s.rotation && (s.rotation = V3.toRadians(s.rotation)), s.modelOnlyRotation && (s.modelOnlyRotation = V3.toRadians(s.modelOnlyRotation)), s.scale = s.scale || [1, 1, 1], s.scale = V3.scale(s.scale, t), s.originalScale = s.scale, 4 > geofs.version && (s.gltf2model = null), (s.model || s.gltf2model) && (r = s.gltf2model ? s.gltf2model.url : s.model.url || s.model, i && "/" != r[0] && !s.include && (r = i + r), o && (r = s.model), l = {
						shadows: s.shadows ? window[s.shadows] : SHADOWS_ALL,
						incrementallyLoadTextures: !1
					}, s.gltf2model && s.gltf2model.shader && (l.customShader = geofs.api.generateShader(s.model.shader, i)), s["3dmodel"] = new geofs.api.Model(r, l), this.models.push(s["3dmodel"]._model), s.renderer && (s.rendererInstance = new instruments.Renderer(s.renderer))), s.light && (s.lightBillboard = new geofs.fx.light(null, s.light, {
						scale: .2
					}), geofs.aircraft.instance.lights.push(s)), s.object3d = new Object3D(s), s.suspension && (s.suspension.length ? (s.suspension.origin = [s.collisionPoints[0][0], s.collisionPoints[0][1], s.collisionPoints[0][2] + s.suspension.length], r = s.suspension.length) : (s.suspension.origin = [s.collisionPoints[0][0], s.collisionPoints[0][1], 0], r = -s.collisionPoints[0][2]), s.suspension.restLength = r, "rotation" == s.suspension.motion ? (r = V3.length(s.collisionPoints[0]), r = Math.atan2(s.collisionPoints[0][0] / r, s.collisionPoints[0][2] / r), r = {
						type: "rotate",
						axis: s.suspension.axis || "Y",
						value: s.name + "Suspension",
						ratio: (0 > r ? r + HALF_PI : r - HALF_PI) * RAD_TO_DEGREES * (s.suspension.ratio || 1)
					}) : r = {
						type: "translate",
						axis: s.suspension.axis || "Z",
						value: s.name + "Suspension",
						ratio: s.suspension.ratio || 1
					}, s.animations.push(r), s.suspension.hardPoint = s.suspension.hardPoint || .5, s.points.suspensionOrigin = V3.dup(s.suspension.origin), geofs.aircraft.instance.suspensions.push(s)), l = 0; l < s.animations.length; l++)(r = s.animations[l]).ratio = r.ratio || 1, r.offset = r.offset || 0, r.currentValue = null, r.delay && (r.ratio /= 1 - Math.abs(r.delay)), "rotate" == r.type && (c = r.method || "rotate", "parent" == r.frame && (c = "rotateParentFrame"), r.rotationMethod = s.object3d[c + r.axis]), "translate" == r.type && (geofs.isArray(r.axis) || (r.axis = AXIS_TO_VECTOR[r.axis]));
				if ("wheel" == s.type && (s.radius = s.radius || 1, s.arcDegree = s.radius * TWO_PI / 360, s.angularVelocity = 0, geofs.aircraft.instance.wheels.push(s)), "airfoil" == s.type && (s.lift = 0, geofs.aircraft.instance.airfoils.push(s), s.stalls = s.stalls || !1, s.stallIncidence = s.stallIncidence || 12, s.zeroLiftIncidence = s.zeroLiftIncidence || 16, s.aspectRatio = s.aspectRatio || DEFAULT_AIRFOIL_ASPECT_RATIO, s.aspectRatioCoefficient = s.aspectRatio / s.aspectRatio + 2), "engine" == s.type && (s.rpm = 0, geofs.aircraft.instance.definition.originalInertia = geofs.aircraft.instance.definition.engineInertia, geofs.aircraft.instance.engines.push(s), s.contrail && (s.contrailEmitter = new geofs.fx.ParticleEmitter({
						off: !0,
						anchor: s.points.contrailAnchor,
						duration: 1e10,
						rate: .05,
						life: 4e4,
						easing: "easeOutQuart",
						startScale: .01,
						endScale: .01,
						randomizeStartScale: .02,
						randomizeEndScale: .15,
						startOpacity: .1,
						endOpacity: 1e-5,
						startRotation: "random",
						texture: "whitesmoke"
					}))), "balloon" == s.type && (s.temperature = s.initialTemperature || 0, s.coolingSpeed = s.coolingSpeed || 0, geofs.aircraft.instance.balloons.push(s)), s.collisionPoints) {
					for (r = s.collisionPoints, l = geofs.aircraft.instance.definition.contactProperties[s.contactType || s.type], c = 0; c < r.length; c++) r[c].part = s, r[c].contactProperties = l, geofs.aircraft.instance.collisionPoints.push(r[c]);
					s.volume || s.buoyancy || (s.volume = "airfoil" == s.type ? this.definition.mass / (400 * r.length) : .1, s.area = s.area || 0), s.dragVector = s.dragVector || [1, 1, 1], s.dragVector = V3.scale(s.dragVector, 1 / r.length)
				}
				s.volume && (s.buoyancy = WATER_DENSITY * GRAVITY * s.volume), s.controller && (geofs.aircraft.instance.controllers[s.controller.name] = s.controller)
			}
			for (n = 0; n < e.length; n++) "root" != (s = e[n]).name && (s.parent || (s.parent = "root"), geofs.aircraft.instance.parts[s.parent].object3d.addChild(s.object3d)), s.node && (s.object3d.setModel(s.object3d.findModelInAncestry()), s.manipulator && ("string" == typeof(i = s.manipulator) && (i = geofs.aircraft.instance.aircraftRecord.isCommunity ? null : geofs.utils.getFunctionFromString(i)), i && (geofs.aircraft.instance.manipulators[s.node] = i, controls.addNodeClickHandler(s.node, (function(e) {
				controls.manipulator = geofs.aircraft.instance.manipulators[e], controls.mouse.down = 4
			})))))
		}
	};
	setInterval((function() {
		Object.values(multiplayer.visibleUsers).forEach((function(i) {
			if (i.lastUpdate.st.lv > 1e3) {
				var t = e.aircraft[i.lastUpdate.st.lv - 1e3].mptx;
				4140 == i.aircraft ? geofs.api.changeModelTexture(i.model._model, t, 1) : geofs.api.changeModelTexture(i.model._model, t, 0)
			}
		}))
	}), 1e3);
	console.log("Loaded!"), console.log("Version: " + version), await fetch("https://raw.githubusercontent.com/Spice9/Geofs-Multiliveries/main/dependencies/contributors.txt").then((e => e.json())).then((e => i = e));
	var d = "";
	setTimeout((function() {
		console.log("Code by Spice9 and AriakimTaiyo, livery contributions by:"), i.forEach((function(e) {
			"" === d ? d += e : d = i[i.length - 1] === e ? d + ", and " + e : d + ", " + e
		})), console.log(d)
	}), 1e3)
}
multiliveries();
